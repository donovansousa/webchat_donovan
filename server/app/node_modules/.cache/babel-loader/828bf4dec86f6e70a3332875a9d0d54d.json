{"ast":null,"code":"'use strict';\n/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar url = require('url'),\n    util = require('util'),\n    http = require('http'),\n    https = require('https'),\n    crypto = require('crypto'),\n    stream = require('stream'),\n    Ultron = require('ultron'),\n    Options = require('options'),\n    Sender = require('./Sender'),\n    Receiver = require('./Receiver'),\n    SenderHixie = require('./Sender.hixie'),\n    ReceiverHixie = require('./Receiver.hixie'),\n    Extensions = require('./Extensions'),\n    PerMessageDeflate = require('./PerMessageDeflate'),\n    EventEmitter = require('events').EventEmitter;\n/**\n * Constants\n */\n// Default protocol version\n\n\nvar protocolVersion = 13; // Close timeout\n\nvar closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly\n\n/**\n * WebSocket implementation\n *\n * @constructor\n * @param {String} address Connection address.\n * @param {String|Array} protocols WebSocket protocols.\n * @param {Object} options Additional connection options.\n * @api public\n */\n\nfunction WebSocket(address, protocols, options) {\n  if (this instanceof WebSocket === false) {\n    return new WebSocket(address, protocols, options);\n  }\n\n  EventEmitter.call(this);\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols;\n    protocols = null;\n  }\n\n  if ('string' === typeof protocols) {\n    protocols = [protocols];\n  }\n\n  if (!Array.isArray(protocols)) {\n    protocols = [];\n  }\n\n  this._socket = null;\n  this._ultron = null;\n  this._closeReceived = false;\n  this.bytesReceived = 0;\n  this.readyState = null;\n  this.supports = {};\n  this.extensions = {};\n  this._binaryType = 'nodebuffer';\n\n  if (Array.isArray(address)) {\n    initAsServerClient.apply(this, address.concat(options));\n  } else {\n    initAsClient.apply(this, [address, protocols, options]);\n  }\n}\n/**\n * Inherits from EventEmitter.\n */\n\n\nutil.inherits(WebSocket, EventEmitter);\n/**\n * Ready States\n */\n\n[\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function each(state, index) {\n  WebSocket.prototype[state] = WebSocket[state] = index;\n});\n/**\n * Gracefully closes the connection, after sending a description message to the server\n *\n * @param {Object} data to be sent to the server\n * @api public\n */\n\nWebSocket.prototype.close = function close(code, data) {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this.readyState === WebSocket.CONNECTING) {\n    this.readyState = WebSocket.CLOSED;\n    return;\n  }\n\n  if (this.readyState === WebSocket.CLOSING) {\n    if (this._closeReceived && this._isServer) {\n      this.terminate();\n    }\n\n    return;\n  }\n\n  var self = this;\n\n  try {\n    this.readyState = WebSocket.CLOSING;\n    this._closeCode = code;\n    this._closeMessage = data;\n    var mask = !this._isServer;\n\n    this._sender.close(code, data, mask, function (err) {\n      if (err) self.emit('error', err);\n\n      if (self._closeReceived && self._isServer) {\n        self.terminate();\n      } else {\n        // ensure that the connection is cleaned up even when no response of closing handshake.\n        clearTimeout(self._closeTimer);\n        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);\n      }\n    });\n  } catch (e) {\n    this.emit('error', e);\n  }\n};\n/**\n * Pause the client stream\n *\n * @api public\n */\n\n\nWebSocket.prototype.pause = function pauser() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n  return this._socket.pause();\n};\n/**\n * Sends a ping\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\n\n\nWebSocket.prototype.ping = function ping(data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.ping(data, options);\n};\n/**\n * Sends a pong\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean\n * @param {boolean} dontFailWhenClosed indicates whether or not to throw if the connection isnt open\n * @api public\n */\n\n\nWebSocket.prototype.pong = function (data, options, dontFailWhenClosed) {\n  if (this.readyState !== WebSocket.OPEN) {\n    if (dontFailWhenClosed === true) return;\n    throw new Error('not opened');\n  }\n\n  options = options || {};\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n\n  this._sender.pong(data, options);\n};\n/**\n * Resume the client stream\n *\n * @api public\n */\n\n\nWebSocket.prototype.resume = function resume() {\n  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n  return this._socket.resume();\n};\n/**\n * Sends a piece of data\n *\n * @param {Object} data to be sent to the server\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} Optional callback which is executed after the send completes\n * @api public\n */\n\n\nWebSocket.prototype.send = function send(data, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));else throw new Error('not opened');\n    return;\n  }\n\n  if (!data) data = '';\n\n  if (this._queue) {\n    var self = this;\n\n    this._queue.push(function () {\n      self.send(data, options, cb);\n    });\n\n    return;\n  }\n\n  options = options || {};\n  options.fin = true;\n\n  if (typeof options.binary === 'undefined') {\n    options.binary = data instanceof ArrayBuffer || data instanceof Buffer || data instanceof Uint8Array || data instanceof Uint16Array || data instanceof Uint32Array || data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array || data instanceof Float32Array || data instanceof Float64Array;\n  }\n\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  var readable = typeof stream.Readable === 'function' ? stream.Readable : stream.Stream;\n\n  if (data instanceof readable) {\n    startQueue(this);\n    var self = this;\n    sendStream(this, data, options, function send(error) {\n      process.nextTick(function tock() {\n        executeQueueSends(self);\n      });\n      if (typeof cb === 'function') cb(error);\n    });\n  } else {\n    this._sender.send(data, options, cb);\n  }\n};\n/**\n * Streams data through calls to a user supplied function\n *\n * @param {Object} Members - mask: boolean, binary: boolean, compress: boolean\n * @param {function} 'function (error, send)' which is executed on successive ticks of which send is 'function (data, final)'.\n * @api public\n */\n\n\nWebSocket.prototype.stream = function stream(options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var self = this;\n  if (typeof cb !== 'function') throw new Error('callback must be provided');\n\n  if (this.readyState !== WebSocket.OPEN) {\n    if (typeof cb === 'function') cb(new Error('not opened'));else throw new Error('not opened');\n    return;\n  }\n\n  if (this._queue) {\n    this._queue.push(function () {\n      self.stream(options, cb);\n    });\n\n    return;\n  }\n\n  options = options || {};\n  if (typeof options.mask === 'undefined') options.mask = !this._isServer;\n  if (typeof options.compress === 'undefined') options.compress = true;\n\n  if (!this.extensions[PerMessageDeflate.extensionName]) {\n    options.compress = false;\n  }\n\n  startQueue(this);\n\n  function send(data, final) {\n    try {\n      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');\n      options.fin = final === true;\n\n      self._sender.send(data, options);\n\n      if (!final) process.nextTick(cb.bind(null, null, send));else executeQueueSends(self);\n    } catch (e) {\n      if (typeof cb === 'function') cb(e);else {\n        delete self._queue;\n        self.emit('error', e);\n      }\n    }\n  }\n\n  process.nextTick(cb.bind(null, null, send));\n};\n/**\n * Immediately shuts down the connection\n *\n * @api public\n */\n\n\nWebSocket.prototype.terminate = function terminate() {\n  if (this.readyState === WebSocket.CLOSED) return;\n\n  if (this._socket) {\n    this.readyState = WebSocket.CLOSING; // End the connection\n\n    try {\n      this._socket.end();\n    } catch (e) {\n      // Socket error during end() call, so just destroy it right now\n      cleanupWebsocketResources.call(this, true);\n      return;\n    } // Add a timeout to ensure that the connection is completely\n    // cleaned up within 30 seconds, even if the clean close procedure\n    // fails for whatever reason\n    // First cleanup any pre-existing timeout from an earlier \"terminate\" call,\n    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts\n    // and hold the program open for `closeTimout` time.\n\n\n    if (this._closeTimer) {\n      clearTimeout(this._closeTimer);\n    }\n\n    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);\n  } else if (this.readyState === WebSocket.CONNECTING) {\n    cleanupWebsocketResources.call(this, true);\n  }\n};\n/**\n * Expose bufferedAmount\n *\n * @api public\n */\n\n\nObject.defineProperty(WebSocket.prototype, 'bufferedAmount', {\n  get: function get() {\n    var amount = 0;\n\n    if (this._socket) {\n      amount = this._socket.bufferSize || 0;\n    }\n\n    return amount;\n  }\n});\n/**\n * Expose binaryType\n *\n * This deviates from the W3C interface since ws doesn't support the required\n * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n *\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\n\nObject.defineProperty(WebSocket.prototype, 'binaryType', {\n  get: function get() {\n    return this._binaryType;\n  },\n  set: function set(type) {\n    if (type === 'arraybuffer' || type === 'nodebuffer') this._binaryType = type;else throw new SyntaxError('unsupported binaryType: must be either \"nodebuffer\" or \"arraybuffer\"');\n  }\n});\n/**\n * Emulates the W3C Browser based WebSocket interface using function members.\n *\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\n\n['open', 'error', 'close', 'message'].forEach(function (method) {\n  Object.defineProperty(WebSocket.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    get: function get() {\n      var listener = this.listeners(method)[0];\n      return listener ? listener._listener ? listener._listener : listener : undefined;\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @returns {Mixed} the set function or undefined\n     * @api public\n     */\n    set: function set(listener) {\n      this.removeAllListeners(method);\n      this.addEventListener(method, listener);\n    }\n  });\n});\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\n\nWebSocket.prototype.addEventListener = function (method, listener) {\n  var target = this;\n\n  function onMessage(data, flags) {\n    if (flags.binary && this.binaryType === 'arraybuffer') data = new Uint8Array(data).buffer;\n    listener.call(target, new MessageEvent(data, !!flags.binary, target));\n  }\n\n  function onClose(code, message) {\n    listener.call(target, new CloseEvent(code, message, target));\n  }\n\n  function onError(event) {\n    event.type = 'error';\n    event.target = target;\n    listener.call(target, event);\n  }\n\n  function onOpen() {\n    listener.call(target, new OpenEvent(target));\n  }\n\n  if (typeof listener === 'function') {\n    if (method === 'message') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      // store a reference so we can return the original function from the\n      // addEventListener hook\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  }\n};\n\nmodule.exports = WebSocket;\nmodule.exports.buildHostHeader = buildHostHeader;\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\n\nfunction MessageEvent(dataArg, isBinary, target) {\n  this.type = 'message';\n  this.data = dataArg;\n  this.target = target;\n  this.binary = isBinary; // non-standard.\n}\n/**\n * W3C CloseEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\n\n\nfunction CloseEvent(code, reason, target) {\n  this.type = 'close';\n  this.wasClean = typeof code === 'undefined' || code === 1000;\n  this.code = code;\n  this.reason = reason;\n  this.target = target;\n}\n/**\n * W3C OpenEvent\n *\n * @see http://www.w3.org/TR/html5/comms.html\n * @constructor\n * @api private\n */\n\n\nfunction OpenEvent(target) {\n  this.type = 'open';\n  this.target = target;\n} // Append port number to Host header, only if specified in the url\n// and non-default\n\n\nfunction buildHostHeader(isSecure, hostname, port) {\n  var headerHost = hostname;\n\n  if (hostname) {\n    if (isSecure && port != 443 || !isSecure && port != 80) {\n      headerHost = headerHost + ':' + port;\n    }\n  }\n\n  return headerHost;\n}\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\n\n\nfunction initAsServerClient(req, socket, upgradeHead, options) {\n  options = new Options({\n    protocolVersion: protocolVersion,\n    protocol: null,\n    extensions: {},\n    maxPayload: 0\n  }).merge(options); // expose state properties\n\n  this.protocol = options.value.protocol;\n  this.protocolVersion = options.value.protocolVersion;\n  this.extensions = options.value.extensions;\n  this.supports.binary = this.protocolVersion !== 'hixie-76';\n  this.upgradeReq = req;\n  this.readyState = WebSocket.CONNECTING;\n  this._isServer = true;\n  this.maxPayload = options.value.maxPayload; // establish connection\n\n  if (options.value.protocolVersion === 'hixie-76') {\n    establishConnection.call(this, ReceiverHixie, SenderHixie, socket, upgradeHead);\n  } else {\n    establishConnection.call(this, Receiver, Sender, socket, upgradeHead);\n  }\n}\n\nfunction initAsClient(address, protocols, options) {\n  options = new Options({\n    origin: null,\n    protocolVersion: protocolVersion,\n    host: null,\n    headers: null,\n    protocol: protocols.join(','),\n    agent: null,\n    // ssl-related options\n    pfx: null,\n    key: null,\n    passphrase: null,\n    cert: null,\n    ca: null,\n    ciphers: null,\n    rejectUnauthorized: null,\n    perMessageDeflate: true,\n    localAddress: null\n  }).merge(options);\n\n  if (options.value.protocolVersion !== 8 && options.value.protocolVersion !== 13) {\n    throw new Error('unsupported protocol version');\n  } // verify URL and establish http class\n\n\n  var serverUrl = url.parse(address);\n  var isUnixSocket = serverUrl.protocol === 'ws+unix:';\n  if (!serverUrl.host && !isUnixSocket) throw new Error('invalid url');\n  var isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  var httpObj = isSecure ? https : http;\n  var port = serverUrl.port || (isSecure ? 443 : 80);\n  var auth = serverUrl.auth; // prepare extensions\n\n  var extensionsOffer = {};\n  var perMessageDeflate;\n\n  if (options.value.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(typeof options.value.perMessageDeflate !== true ? options.value.perMessageDeflate : {}, false);\n    extensionsOffer[PerMessageDeflate.extensionName] = perMessageDeflate.offer();\n  } // expose state properties\n\n\n  this._isServer = false;\n  this.url = address;\n  this.protocolVersion = options.value.protocolVersion;\n  this.supports.binary = this.protocolVersion !== 'hixie-76'; // begin handshake\n\n  var key = new Buffer(options.value.protocolVersion + '-' + Date.now()).toString('base64');\n  var shasum = crypto.createHash('sha1');\n  shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  var expectedServerKey = shasum.digest('base64');\n  var agent = options.value.agent;\n  var headerHost = buildHostHeader(isSecure, serverUrl.hostname, port);\n  var requestOptions = {\n    port: port,\n    host: serverUrl.hostname,\n    headers: {\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket',\n      'Host': headerHost,\n      'Sec-WebSocket-Version': options.value.protocolVersion,\n      'Sec-WebSocket-Key': key\n    }\n  }; // If we have basic auth.\n\n  if (auth) {\n    requestOptions.headers.Authorization = 'Basic ' + new Buffer(auth).toString('base64');\n  }\n\n  if (options.value.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.value.protocol;\n  }\n\n  if (options.value.host) {\n    requestOptions.headers.Host = options.value.host;\n  }\n\n  if (options.value.headers) {\n    for (var header in options.value.headers) {\n      if (options.value.headers.hasOwnProperty(header)) {\n        requestOptions.headers[header] = options.value.headers[header];\n      }\n    }\n  }\n\n  if (Object.keys(extensionsOffer).length) {\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format(extensionsOffer);\n  }\n\n  if (options.isDefinedAndNonNull('pfx') || options.isDefinedAndNonNull('key') || options.isDefinedAndNonNull('passphrase') || options.isDefinedAndNonNull('cert') || options.isDefinedAndNonNull('ca') || options.isDefinedAndNonNull('ciphers') || options.isDefinedAndNonNull('rejectUnauthorized')) {\n    if (options.isDefinedAndNonNull('pfx')) requestOptions.pfx = options.value.pfx;\n    if (options.isDefinedAndNonNull('key')) requestOptions.key = options.value.key;\n    if (options.isDefinedAndNonNull('passphrase')) requestOptions.passphrase = options.value.passphrase;\n    if (options.isDefinedAndNonNull('cert')) requestOptions.cert = options.value.cert;\n    if (options.isDefinedAndNonNull('ca')) requestOptions.ca = options.value.ca;\n    if (options.isDefinedAndNonNull('ciphers')) requestOptions.ciphers = options.value.ciphers;\n    if (options.isDefinedAndNonNull('rejectUnauthorized')) requestOptions.rejectUnauthorized = options.value.rejectUnauthorized;\n\n    if (!agent) {\n      // global agent ignores client side certificates\n      agent = new httpObj.Agent(requestOptions);\n    }\n  }\n\n  requestOptions.path = serverUrl.path || '/';\n\n  if (agent) {\n    requestOptions.agent = agent;\n  }\n\n  if (isUnixSocket) {\n    requestOptions.socketPath = serverUrl.pathname;\n  }\n\n  if (options.value.localAddress) {\n    requestOptions.localAddress = options.value.localAddress;\n  }\n\n  if (options.value.origin) {\n    if (options.value.protocolVersion < 13) requestOptions.headers['Sec-WebSocket-Origin'] = options.value.origin;else requestOptions.headers.Origin = options.value.origin;\n  }\n\n  var self = this;\n  var req = httpObj.request(requestOptions);\n  req.on('error', function onerror(error) {\n    self.emit('error', error);\n    cleanupWebsocketResources.call(self, error);\n  });\n  req.once('response', function response(res) {\n    var error;\n\n    if (!self.emit('unexpected-response', req, res)) {\n      error = new Error('unexpected server response (' + res.statusCode + ')');\n      req.abort();\n      self.emit('error', error);\n    }\n\n    cleanupWebsocketResources.call(self, error);\n  });\n  req.once('upgrade', function upgrade(res, socket, upgradeHead) {\n    if (self.readyState === WebSocket.CLOSED) {\n      // client closed before server accepted connection\n      self.emit('close');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverKey = res.headers['sec-websocket-accept'];\n\n    if (typeof serverKey === 'undefined' || serverKey !== expectedServerKey) {\n      self.emit('error', 'invalid server key');\n      self.removeAllListeners();\n      socket.end();\n      return;\n    }\n\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protList = (options.value.protocol || \"\").split(/, */);\n    var protError = null;\n\n    if (!options.value.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.value.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      self.emit('error', protError);\n      self.removeAllListeners();\n      socket.end();\n      return;\n    } else if (serverProt) {\n      self.protocol = serverProt;\n    }\n\n    var serverExtensions = Extensions.parse(res.headers['sec-websocket-extensions']);\n\n    if (perMessageDeflate && serverExtensions[PerMessageDeflate.extensionName]) {\n      try {\n        perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        self.emit('error', 'invalid extension parameter');\n        self.removeAllListeners();\n        socket.end();\n        return;\n      }\n\n      self.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    establishConnection.call(self, Receiver, Sender, socket, upgradeHead); // perform cleanup on http resources\n\n    req.removeAllListeners();\n    req = null;\n    agent = null;\n  });\n  req.end();\n  this.readyState = WebSocket.CONNECTING;\n}\n\nfunction establishConnection(ReceiverClass, SenderClass, socket, upgradeHead) {\n  var ultron = this._ultron = new Ultron(socket),\n      called = false,\n      self = this;\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n  this._receiver = new ReceiverClass(this.extensions, this.maxPayload);\n  this._socket = socket; // socket cleanup handlers\n\n  ultron.on('end', cleanupWebsocketResources.bind(this));\n  ultron.on('close', cleanupWebsocketResources.bind(this));\n  ultron.on('error', cleanupWebsocketResources.bind(this)); // ensure that the upgradeHead is added to the receiver\n\n  function firstHandler(data) {\n    if (called || self.readyState === WebSocket.CLOSED) return;\n    called = true;\n    socket.removeListener('data', firstHandler);\n    ultron.on('data', realHandler);\n\n    if (upgradeHead && upgradeHead.length > 0) {\n      realHandler(upgradeHead);\n      upgradeHead = null;\n    }\n\n    if (data) realHandler(data);\n  } // subsequent packets are pushed straight to the receiver\n\n\n  function realHandler(data) {\n    self.bytesReceived += data.length;\n\n    self._receiver.add(data);\n  }\n\n  ultron.on('data', firstHandler); // if data was passed along with the http upgrade,\n  // this will schedule a push of that on to the receiver.\n  // this has to be done on next tick, since the caller\n  // hasn't had a chance to set event handlers on this client\n  // object yet.\n\n  process.nextTick(firstHandler); // receiver event handlers\n\n  self._receiver.ontext = function ontext(data, flags) {\n    flags = flags || {};\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onbinary = function onbinary(data, flags) {\n    flags = flags || {};\n    flags.binary = true;\n    self.emit('message', data, flags);\n  };\n\n  self._receiver.onping = function onping(data, flags) {\n    flags = flags || {};\n    self.pong(data, {\n      mask: !self._isServer,\n      binary: flags.binary === true\n    }, true);\n    self.emit('ping', data, flags);\n  };\n\n  self._receiver.onpong = function onpong(data, flags) {\n    self.emit('pong', data, flags || {});\n  };\n\n  self._receiver.onclose = function onclose(code, data, flags) {\n    flags = flags || {};\n    self._closeReceived = true;\n    self.close(code, data);\n  };\n\n  self._receiver.onerror = function onerror(reason, errorCode) {\n    // close the connection when the receiver reports a HyBi error code\n    self.close(typeof errorCode !== 'undefined' ? errorCode : 1002, '');\n    self.emit('error', reason instanceof Error ? reason : new Error(reason));\n  }; // finalize the client\n\n\n  this._sender = new SenderClass(socket, this.extensions);\n\n  this._sender.on('error', function onerror(error) {\n    self.close(1002, '');\n    self.emit('error', error);\n  });\n\n  this.readyState = WebSocket.OPEN;\n  this.emit('open');\n}\n\nfunction startQueue(instance) {\n  instance._queue = instance._queue || [];\n}\n\nfunction executeQueueSends(instance) {\n  var queue = instance._queue;\n  if (typeof queue === 'undefined') return;\n  delete instance._queue;\n\n  for (var i = 0, l = queue.length; i < l; ++i) {\n    queue[i]();\n  }\n}\n\nfunction sendStream(instance, stream, options, cb) {\n  stream.on('data', function incoming(data) {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = false;\n\n    instance._sender.send(data, options);\n  });\n  stream.on('end', function end() {\n    if (instance.readyState !== WebSocket.OPEN) {\n      if (typeof cb === 'function') cb(new Error('not opened'));else {\n        delete instance._queue;\n        instance.emit('error', new Error('not opened'));\n      }\n      return;\n    }\n\n    options.fin = true;\n\n    instance._sender.send(null, options);\n\n    if (typeof cb === 'function') cb(null);\n  });\n}\n\nfunction cleanupWebsocketResources(error) {\n  if (this.readyState === WebSocket.CLOSED) return;\n  this.readyState = WebSocket.CLOSED;\n  clearTimeout(this._closeTimer);\n  this._closeTimer = null; // If the connection was closed abnormally (with an error), or if\n  // the close control frame was not received then the close code\n  // must default to 1006.\n\n  if (error || !this._closeReceived) {\n    this._closeCode = 1006;\n  }\n\n  this.emit('close', this._closeCode || 1000, this._closeMessage || '');\n\n  if (this._socket) {\n    if (this._ultron) this._ultron.destroy();\n\n    this._socket.on('error', function onerror() {\n      try {\n        this.destroy();\n      } catch (e) {}\n    });\n\n    try {\n      if (!error) this._socket.end();else this._socket.destroy();\n    } catch (e) {\n      /* Ignore termination errors */\n    }\n\n    this._socket = null;\n    this._ultron = null;\n  }\n\n  if (this._sender) {\n    this._sender.removeAllListeners();\n\n    this._sender = null;\n  }\n\n  if (this._receiver) {\n    this._receiver.cleanup();\n\n    this._receiver = null;\n  }\n\n  if (this.extensions[PerMessageDeflate.extensionName]) {\n    this.extensions[PerMessageDeflate.extensionName].cleanup();\n  }\n\n  this.extensions = null;\n  this.removeAllListeners();\n  this.on('error', function onerror() {}); // catch all errors after this\n\n  delete this._queue;\n}","map":null,"metadata":{},"sourceType":"script"}