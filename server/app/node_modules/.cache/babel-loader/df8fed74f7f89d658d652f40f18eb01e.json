{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\nvar util = require('util');\n/**\n * State constants\n */\n\n\nvar EMPTY = 0,\n    BODY = 1;\nvar BINARYLENGTH = 2,\n    BINARYBODY = 3;\n/**\n * Hixie Receiver implementation\n */\n\nfunction Receiver() {\n  if (this instanceof Receiver === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n  this.dead = false;\n\n  this.onerror = function () {};\n\n  this.ontext = function () {};\n\n  this.onbinary = function () {};\n\n  this.onclose = function () {};\n\n  this.onping = function () {};\n\n  this.onpong = function () {};\n}\n\nmodule.exports = Receiver;\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function (data) {\n  if (this.dead) return;\n  var self = this;\n\n  function doAdd() {\n    if (self.state === EMPTY) {\n      if (data.length == 2 && data[0] == 0xFF && data[1] == 0x00) {\n        self.reset();\n        self.onclose();\n        return;\n      }\n\n      if (data[0] === 0x80) {\n        self.messageEnd = 0;\n        self.state = BINARYLENGTH;\n        data = data.slice(1);\n      } else {\n        if (data[0] !== 0x00) {\n          self.error('payload must start with 0x00 byte', true);\n          return;\n        }\n\n        data = data.slice(1);\n        self.state = BODY;\n      }\n    }\n\n    if (self.state === BINARYLENGTH) {\n      var i = 0;\n\n      while (i < data.length && data[i] & 0x80) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        ++i;\n      }\n\n      if (i < data.length) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        self.state = BINARYBODY;\n        ++i;\n      }\n\n      if (i > 0) data = data.slice(i);\n    }\n\n    if (self.state === BINARYBODY) {\n      var dataleft = self.messageEnd - self.spanLength;\n\n      if (data.length >= dataleft) {\n        // consume the whole buffer to finish the frame\n        self.buffers.push(data);\n        self.spanLength += dataleft;\n        self.messageEnd = dataleft;\n        return self.parse();\n      } // frame's not done even if we consume it all\n\n\n      self.buffers.push(data);\n      self.spanLength += data.length;\n      return;\n    }\n\n    self.buffers.push(data);\n\n    if ((self.messageEnd = bufferIndex(data, 0xFF)) != -1) {\n      self.spanLength += self.messageEnd;\n      return self.parse();\n    } else self.spanLength += data.length;\n  }\n\n  while (data) {\n    data = doAdd();\n  }\n};\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\n\nReceiver.prototype.cleanup = function () {\n  this.dead = true;\n  this.state = EMPTY;\n  this.buffers = [];\n};\n/**\n * Process buffered data.\n *\n * @api public\n */\n\n\nReceiver.prototype.parse = function () {\n  var output = new Buffer(this.spanLength);\n  var outputIndex = 0;\n\n  for (var bi = 0, bl = this.buffers.length; bi < bl - 1; ++bi) {\n    var buffer = this.buffers[bi];\n    buffer.copy(output, outputIndex);\n    outputIndex += buffer.length;\n  }\n\n  var lastBuffer = this.buffers[this.buffers.length - 1];\n  if (this.messageEnd > 0) lastBuffer.copy(output, outputIndex, 0, this.messageEnd);\n  if (this.state !== BODY) --this.messageEnd;\n  var tail = null;\n\n  if (this.messageEnd < lastBuffer.length - 1) {\n    tail = lastBuffer.slice(this.messageEnd + 1);\n  }\n\n  this.reset();\n  this.ontext(output.toString('utf8'));\n  return tail;\n};\n/**\n * Handles an error\n *\n * @api private\n */\n\n\nReceiver.prototype.error = function (reason, terminate) {\n  if (this.dead) return;\n  this.reset();\n\n  if (typeof reason == 'string') {\n    this.onerror(new Error(reason), terminate);\n  } else if (reason.constructor == Error) {\n    this.onerror(reason, terminate);\n  } else {\n    this.onerror(new Error(\"An error occured\"), terminate);\n  }\n\n  return this;\n};\n/**\n * Reset parser state\n *\n * @api private\n */\n\n\nReceiver.prototype.reset = function (reason) {\n  if (this.dead) return;\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n};\n/**\n * Internal api\n */\n\n\nfunction bufferIndex(buffer, byte) {\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    if (buffer[i] === byte) return i;\n  }\n\n  return -1;\n}","map":null,"metadata":{},"sourceType":"script"}