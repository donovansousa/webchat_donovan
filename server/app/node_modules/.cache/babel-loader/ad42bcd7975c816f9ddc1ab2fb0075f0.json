{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\nvar events = require('events'),\n    util = require('util'),\n    EventEmitter = events.EventEmitter;\n/**\n * Hixie Sender implementation\n */\n\n\nfunction Sender(socket) {\n  if (this instanceof Sender === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  events.EventEmitter.call(this);\n  this.socket = socket;\n  this.continuationFrame = false;\n  this.isClosed = false;\n}\n\nmodule.exports = Sender;\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n/**\n * Frames and writes data.\n *\n * @api public\n */\n\nSender.prototype.send = function (data, options, cb) {\n  if (this.isClosed) return;\n  var isString = typeof data == 'string',\n      length = isString ? Buffer.byteLength(data) : data.length,\n      lengthbytes = length > 127 ? 2 : 1 // assume less than 2**14 bytes\n  ,\n      writeStartMarker = this.continuationFrame == false,\n      writeEndMarker = !options || !(typeof options.fin != 'undefined' && !options.fin),\n      buffer = new Buffer((writeStartMarker ? options && options.binary ? 1 + lengthbytes : 1 : 0) + length + (writeEndMarker && !(options && options.binary) ? 1 : 0)),\n      offset = writeStartMarker ? 1 : 0;\n\n  if (writeStartMarker) {\n    if (options && options.binary) {\n      buffer.write('\\x80', 'binary'); // assume length less than 2**14 bytes\n\n      if (lengthbytes > 1) buffer.write(String.fromCharCode(128 + length / 128), offset++, 'binary');\n      buffer.write(String.fromCharCode(length & 0x7f), offset++, 'binary');\n    } else buffer.write('\\x00', 'binary');\n  }\n\n  if (isString) buffer.write(data, offset, 'utf8');else data.copy(buffer, offset, 0);\n\n  if (writeEndMarker) {\n    if (options && options.binary) {// sending binary, not writing end marker\n    } else buffer.write('\\xff', offset + length, 'binary');\n\n    this.continuationFrame = false;\n  } else this.continuationFrame = true;\n\n  try {\n    this.socket.write(buffer, 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\n\nSender.prototype.close = function (code, data, mask, cb) {\n  if (this.isClosed) return;\n  this.isClosed = true;\n\n  try {\n    if (this.continuationFrame) this.socket.write(new Buffer([0xff], 'binary'));\n    this.socket.write(new Buffer([0xff, 0x00]), 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n/**\n * Sends a ping message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\n\nSender.prototype.ping = function (data, options) {};\n/**\n * Sends a pong message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\n\nSender.prototype.pong = function (data, options) {};\n/**\n * Handles an error\n *\n * @api private\n */\n\n\nSender.prototype.error = function (reason) {\n  this.emit('error', reason);\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}